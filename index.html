<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Live Border Wait Times Dashboard</title>
    <style>
        body { font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif; background-color: #f0f2f5; margin: 0; }
        .dashboard { max-width: 1200px; margin: auto; padding: 20px; }
        .header-container { display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 10px; }
        #last-updated { font-size: 0.9em; color: #555; background-color: #e9ecef; padding: 5px 10px; border-radius: 5px; transition: opacity 0.3s; }
        .port-section { margin-bottom: 40px; background-color: #ffffff; border-radius: 8px; box-shadow: 0 4px 8px rgba(0,0,0,0.05); overflow: hidden; }
        .port-title { font-size: 2em; color: #1c2a38; margin-bottom: 20px; border-bottom: 3px solid #e0e0e0; padding-bottom: 10px; }
        .port-layout { display: flex; flex-wrap: wrap; gap: 40px; padding: 20px 40px 40px; max-height: 0; overflow: hidden; transition: max-height 0.4s ease-out; }
        .category-column { flex: 1; min-width: 300px; }
        .category-title { font-size: 1.5em; color: #444; margin-top: 0; }
        .category-header { display: flex; align-items: baseline; gap: 15px; flex-wrap: wrap; margin-bottom: 10px; }
        .operating-hours { font-size: 0.9em; color: #6c757d; margin: 0; font-style: italic; }
        .filter-controls { background-color: #fff; padding: 15px 20px; border-radius: 8px; margin-bottom: 20px; box-shadow: 0 2px 4px rgba(0,0,0,0.05); display: flex; gap: 40px; align-items: center; flex-wrap: wrap; }
        .filter-controls > div { display: flex; align-items: center; gap: 15px; flex-wrap: wrap; }
        .filter-controls h3 { margin: 0; font-size: 1em; color: #333; }
        .filter-controls label { cursor: pointer; user-select: none; }
        .port-title.collapsible { cursor: pointer; position: relative; user-select: none; margin: 0; padding: 20px 40px; border-bottom: 1px solid #e0e0e0; }
        .port-title.collapsible::after { content: '+'; font-weight: bold; position: absolute; right: 10px; transition: transform 0.2s ease-in-out; font-size: 1.5em; top: 50%; transform: translateY(-55%); }
        .port-title.collapsible.active::after { content: 'âˆ’'; }
        .card-container { display: flex; flex-wrap: wrap; gap: 20px; }
        .card { background-color: white; border-radius: 8px; box-shadow: 0 4px 6px rgba(0,0,0,0.1); padding: 20px; border-left: 5px solid #ccc; display: flex; flex-direction: column; flex: 1; min-width: 160px; }
        .card.status-no-data { background-color: #f8f9fa; border-left-color: #e0e0e0; }
        .card.status-closed .wait-time, .card.status-no-data .wait-time { color: #6c757d; }
        .card h3 { margin-top: 0; font-size: 1.25em; color: #333; }
        .card .wait-time { font-size: 3em; font-weight: 700; margin: 10px 0; }
        .card .lanes-open { font-size: 1em; color: #555; font-weight: 600; flex-grow: 1; }
        .card .last-updated { font-size: 0.9em; color: #777; margin-top: 15px; }
        .status-green { border-left-color: #28a745; }
        .status-yellow { border-left-color: #ffc107; }
        .status-red { border-left-color: #dc3545; }
    </style>
</head>
<body>
    <div id="dashboard" class="dashboard">
        <div class="header-container">
            <h1>Live Border Wait Times</h1>
            <span id="last-updated"></span>
        </div>
        <div class="filter-controls">
            <div id="port-filter-container">
                <h3>Port of Entry:</h3>
                <!-- Port filters will be dynamically inserted here -->
            </div>
            <div>
                <h3>Mode:</h3>
                <label><input type="checkbox" name="mode-filter" value="Vehicles" checked> Vehicles</label>
                <label><input type="checkbox" name="mode-filter" value="Pedestrians" checked> Pedestrians</label>
            </div>
            <div>
                <h3>Lane Type:</h3>
                <label><input type="checkbox" name="lane-filter" value="General" checked> General</label>
                <label><input type="checkbox" name="lane-filter" value="Ready" checked> Ready</label>
                <label><input type="checkbox" name="lane-filter" value="Sentri" checked> Sentri</label>
            </div>
        </div>
        <p id="loading">Loading live data from CBP...</p>
    </div>

    <script>
        const rssUrl = 'https://bwt.cbp.gov/api/bwtRss/CSV/-1/57,55/57,55,106';
        const fetchUrl = rssUrl;
        const REFRESH_INTERVAL_MS = 5 * 60 * 1000; // 5 minutes

        // DOM Element References
        const dashboardContainer = document.getElementById('dashboard');
        const loadingMessage = document.getElementById('loading');
        const lastUpdatedEl = document.getElementById('last-updated');

        // --- STATE MANAGEMENT ---
        const appState = {
            ports: {},
            filters: {
                ports: [],
                modes: [],
                lanes: []
            }
        };

        // =================================================================================
        // --- DATA LAYER ---
        // Responsible for fetching and parsing data from the API.
        // =================================================================================

        async function fetchAndParseData() {
            const response = await fetch(fetchUrl);
            if (!response.ok) throw new Error(`Network response was not ok: ${response.statusText}`);
            const xmlText = await response.text();

            const parser = new DOMParser();
            const xmlDoc = parser.parseFromString(xmlText, "text/xml");
            const items = xmlDoc.getElementsByTagName('item');
            console.log(`Found ${items.length} items in the RSS feed.`);
            const portData = {};

            for (const item of items) {
                const originalPortName = item.querySelector('title').textContent;
                const portName = originalPortName.split(' - ')[0];
                const description = item.querySelector('description').textContent;
                const hoursInfo = getOperatingHoursInfo(description); // Parse hours from the full description for all types.

                if (!portData[portName]) {
                    portData[portName] = createPortTemplate(portName);
                }

                const vehicleChunk = description.split('Passenger Vehicles')[1]?.split('Pedestrian')[0] || '';
                const pedestrianChunk = description.split('Pedestrian')[1] || '';

                if (originalPortName.includes('PedWest')) {
                    const generalData = extractLaneData(description, 'General Lanes');
                    const readyData = extractLaneData(description, 'Ready Lanes');

                    if (!hoursInfo.isCurrentlyOpen) {
                        generalData.status = 'Closed';
                        generalData.updateTime = `At ${hoursInfo.closingTimeText}`;
                        readyData.status = 'Closed';
                        readyData.updateTime = `At ${hoursInfo.closingTimeText}`;
                    }

                    portData[portName].pedwest = {
                        'General': generalData,
                        'Ready': readyData,
                        operatingHours: hoursInfo.operatingHoursText
                    };
                } else {
                    portData[portName].vehicles.operatingHours = hoursInfo.operatingHoursText;
                    ['General', 'Ready', 'Sentri'].forEach(laneName => {
                        const laneData = extractLaneData(vehicleChunk, `${laneName} Lanes`);
                        if (!hoursInfo.isCurrentlyOpen) {
                            laneData.status = 'Closed';
                            laneData.updateTime = `At ${hoursInfo.closingTimeText}`;
                        }
                        portData[portName].vehicles[laneName] = laneData;
                    });

                    portData[portName].pedestrians.operatingHours = hoursInfo.operatingHoursText;
                    ['General', 'Ready'].forEach(laneName => {
                        const laneData = extractLaneData(pedestrianChunk, `${laneName} Lanes`);
                        if (!hoursInfo.isCurrentlyOpen) {
                            laneData.status = 'Closed';
                            laneData.updateTime = `At ${hoursInfo.closingTimeText}`;
                        }
                        portData[portName].pedestrians[laneName] = laneData;
                    });
                }
            }
            console.log("%c--- All items parsed. Final data structure: ---", "font-weight: bold; font-size: 1.2em;", portData);
            return portData;
        }

        /**
         * A targeted function to extract data for one specific lane from a text block.
         */
        function extractLaneData(textChunk, laneFullName) {
            console.groupCollapsed(`Extracting data for: "${laneFullName}"`);
            const laneData = { status: 'N/A', waitTime: 'N/A', lanesOpen: 'N/A', updateTime: '' };

            if (!textChunk || !textChunk.includes(laneFullName + ":")) {
                console.log(`Lane not found in provided text chunk.`);
                console.groupEnd();
                return laneData;
            }

            const laneChunk = textChunk.split(laneFullName + ":")[1] || '';
            console.log(`Raw lane chunk:`, laneChunk);

            if (laneChunk.includes("Lanes Closed")) {
                laneData.status = 'Closed';
                laneData.lanesOpen = '0';
            } else {
                const waitMatch = laneChunk.match(/(\d+)\s+min delay/);
                const lanesMatch = laneChunk.match(/(\d+)\s+lane\(s\)\s+open/);
                const timeMatch = laneChunk.match(/At\s+([\d:]+\s*[ap]m\s*\w+)/);

                if (waitMatch) {
                    laneData.status = 'Open';
                    laneData.waitTime = waitMatch[1];
                    laneData.lanesOpen = lanesMatch ? lanesMatch[1] : '?';
                    laneData.updateTime = timeMatch ? timeMatch[0] : '';
                }
            }
            console.log(`Result:`, laneData);
            console.groupEnd();
            return laneData;
        }

        /**
         * Finds and parses operating hours from a text chunk.
         * @param {string} textChunk The text to search within.
         * @returns {{operatingHoursText: string, isCurrentlyOpen: boolean, closingTimeText: string}}
         */
        function getOperatingHoursInfo(textChunk) {
            const defaultInfo = { operatingHoursText: '', isCurrentlyOpen: true, closingTimeText: '' };
            if (!textChunk) return defaultInfo;

            const hoursMatch = textChunk.match(/(\d+\s*[ap]m-\d+\s*[ap]m)/);
            if (!hoursMatch) return defaultInfo;

            const operatingHoursText = hoursMatch[0];
            const operatingHours = parseOperatingHours(operatingHoursText);

            if (operatingHours) {
                const formattedClosingTime = formatHour(operatingHours.endHour);
                return { operatingHoursText, isCurrentlyOpen: isCurrentlyOpen(operatingHours), closingTimeText: formattedClosingTime };
            }

            return defaultInfo;
        }

        /**
         * Parses an hours string like "6am-2pm" into an object with start and end hours.
         * @param {string} hoursString The string to parse.
         * @returns {{startHour: number, endHour: number}|null}
         */
        function parseOperatingHours(hoursString) {
            try {
                const [startStr, endStr] = hoursString.replace(/\s/g, '').split('-');

                const parseTime = (timeStr) => {
                    let hour = parseInt(timeStr.match(/\d+/)[0], 10);
                    const isPM = timeStr.includes('pm');

                    if (isPM && hour !== 12) {
                        hour += 12;
                    } else if (!isPM && hour === 12) { // 12am is midnight (hour 0)
                        hour = 0;
                    }
                    return hour;
                };

                return { startHour: parseTime(startStr), endHour: parseTime(endStr) };
            } catch (e) {
                console.error(`Could not parse operating hours: "${hoursString}"`, e);
                return null;
            }
        }

        /**
         * Formats a 24-hour number into a "h:00 am/pm" string.
         * @param {number} hour The hour in 24-hour format (0-23).
         * @returns {string}
         */
        function formatHour(hour) {
            const h = hour % 12 === 0 ? 12 : hour % 12;
            const ampm = hour >= 12 ? 'pm' : 'am';
            // The source data is by the hour, so we add ":00".
            return `${h}:00 ${ampm}`;
        }

        /**
         * Checks if the current time is within a given operating hours window.
         */
        function isCurrentlyOpen({ startHour, endHour }) {
            const currentHour = new Date().getHours();
            // Handles overnight hours (e.g., 10pm - 6am)
            if (startHour > endHour) return currentHour >= startHour || currentHour < endHour;
            return currentHour >= startHour && currentHour < endHour;
        }

        /**
         * Creates a blank "template" object for a port with all possible lanes.
         */
        function createPortTemplate(portName) {
            const laneTemplate = () => ({ status: 'N/A', waitTime: 'N/A', lanesOpen: 'N/A', updateTime: '' });
            return {
                portName: portName,
                vehicles: { 'General': laneTemplate(), 'Ready': laneTemplate(), 'Sentri': laneTemplate() },
                pedestrians: { 'General': laneTemplate(), 'Ready': laneTemplate(), 'Sentri': laneTemplate() }
            };
        }

        // =================================================================================
        // --- UI / RENDERING LAYER ---
        // Responsible for creating and updating DOM elements.
        // =================================================================================

        function renderDashboard() {
            console.log("%c--- Starting DOM Generation ---", "font-weight: bold; font-size: 1.2em;");

            // Clear existing port sections before re-rendering
            document.querySelectorAll('.port-section').forEach(el => el.remove());

            const { ports, filters } = appState;
            const fragment = document.createDocumentFragment();

            Object.values(ports)
                .filter(port => filters.ports.includes(port.portName))
                .forEach(port => {
                    const portSection = createPortSectionElement(port);
                    if (portSection) {
                        fragment.appendChild(portSection);
                    }
                });

            dashboardContainer.appendChild(fragment);
            initializeAccordions();
        }

        function createPortSectionElement(port) {
            const { filters } = appState;
            const portSection = document.createElement('section');
            portSection.className = 'port-section';

            const header = document.createElement('h2');
            header.className = 'port-title collapsible';
            header.textContent = port.portName;

            const layout = document.createElement('div');
            layout.className = 'port-layout';

            const categories = {
                Vehicles: port.vehicles,
                Pedestrians: port.pedestrians,
                PedWest: port.pedwest
            };

            for (const [mode, categoryData] of Object.entries(categories)) {
                if (!categoryData || !filters.modes.includes(mode === 'PedWest' ? 'Pedestrians' : mode)) continue;

                // Filter out non-lane properties like 'operatingHours' by checking if the value is an object
                const visibleLanes = Object.entries(categoryData)
                    .filter(([name, data]) => typeof data === 'object' && data.status !== 'N/A' && filters.lanes.includes(name));

                if (visibleLanes.length > 0) {
                    const categoryColumn = document.createElement('div');
                    categoryColumn.className = 'category-column';

                    const categoryHeader = document.createElement('div');
                    categoryHeader.className = 'category-header';
                    categoryHeader.innerHTML = `<h3 class="category-title">${mode}</h3>`;

                    if (categoryData.operatingHours) {
                        const hoursEl = document.createElement('p');
                        hoursEl.className = 'operating-hours';
                        hoursEl.textContent = `Hours: ${categoryData.operatingHours}`;
                        categoryHeader.appendChild(hoursEl);
                    }
                    categoryColumn.appendChild(categoryHeader);

                    const cardContainer = document.createElement('div');
                    cardContainer.className = 'card-container';

                    visibleLanes.forEach(([laneName, laneData]) => {
                        cardContainer.appendChild(createCardElement(laneName, laneData));
                    });
                    categoryColumn.appendChild(cardContainer);
                    layout.appendChild(categoryColumn);
                }
            }

            if (layout.hasChildNodes()) {
                portSection.append(header, layout);
                return portSection;
            }
            return null; // Return null if the port has no visible categories
        }

        function createCardElement(laneName, lane) {
            const card = document.createElement('div');
            const waitTimeDisplay = lane.status === 'Open' ? `${lane.waitTime} min` : lane.status;
            const lanesOpenDisplay = lane.status === 'Closed' ? 'All lanes closed' : (lane.lanesOpen !== 'N/A' ? `${lane.lanesOpen} lane(s) open` : '');
            card.className = `card ${getStatusColor(lane.status, lane.waitTime)}`;
            card.innerHTML = `
                <h3>${laneName}</h3>
                <div class="wait-time">${waitTimeDisplay}</div>
                <div class="lanes-open">${lanesOpenDisplay}</div>
                <div class="last-updated">${lane.updateTime}</div>
            `;
            return card;
        }

        function updateFilterControls(portNames) {
            const portFilterContainer = document.getElementById('port-filter-container');
            portFilterContainer.innerHTML = '<h3>Port of Entry:</h3>'; // Clear previous
            portNames.forEach(portName => {
                portFilterContainer.innerHTML += `
                    <label><input type="checkbox" name="port-filter" value="${portName}" checked> ${portName}</label>
                `;
            });
        }

        function initializeAccordions() {
            document.querySelectorAll('.port-title.collapsible').forEach(header => {
                // Start expanded
                header.classList.add('active');
                const content = header.nextElementSibling;
                content.style.maxHeight = content.scrollHeight + 'px';

                header.addEventListener('click', () => {
                    header.classList.toggle('active');
                    content.style.maxHeight = header.classList.contains('active') ? content.scrollHeight + 'px' : '0px';
                });
            });
        }

        // =================================================================================
        // --- CONTROLLER LAYER ---
        // Manages state, user events, and orchestrates the app.
        // =================================================================================

        async function main() {
            try {
                const portData = await fetchAndParseData();
                appState.ports = portData;

                const portNames = Object.keys(portData);
                updateFilterControls(portNames);
                updateFiltersFromDOM();

                if (loadingMessage) loadingMessage.style.display = 'none';
                renderDashboard();
                setupEventListeners();

                updateLastUpdatedTimestamp();
                setInterval(refreshData, REFRESH_INTERVAL_MS);

            } catch (error) {
                if (loadingMessage) loadingMessage.textContent = 'Failed to load data. The API may be down.';
                console.error('Initialization Error:', error);
            }
        }

        function updateFiltersFromDOM() {
            appState.filters.ports = Array.from(document.querySelectorAll('input[name="port-filter"]:checked')).map(cb => cb.value);
            appState.filters.modes = Array.from(document.querySelectorAll('input[name="mode-filter"]:checked')).map(cb => cb.value);
            appState.filters.lanes = Array.from(document.querySelectorAll('input[name="lane-filter"]:checked')).map(cb => cb.value);
        }

        function setupEventListeners() {
            document.querySelector('.filter-controls').addEventListener('change', () => {
                updateFiltersFromDOM();
                renderDashboard();
            });
        }

        async function refreshData() {
            console.log("Refreshing data...");
            lastUpdatedEl.style.opacity = '0.5';
            try {
                appState.ports = await fetchAndParseData();
                renderDashboard();
                updateLastUpdatedTimestamp();
            } catch (error) {
                console.error("Failed to refresh data:", error);
            } finally {
                lastUpdatedEl.style.opacity = '1';
            }
        }

        function updateLastUpdatedTimestamp() {
            const now = new Date();
            lastUpdatedEl.textContent = `Last Updated: ${now.toLocaleTimeString()}`;
        }

        function getStatusColor(status, waitTime) {
            if (status !== 'Open') return 'status-closed';
            const minutes = parseInt(waitTime, 10);
            if (isNaN(minutes)) return '';
            if (minutes <= 20) return 'status-green';
            if (minutes <= 60) return 'status-yellow';
            return 'status-red';
        }

        // --- App Initialization ---
        main();

    </script>
</body>
</html>