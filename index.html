<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Live Border Wait Times</title>
    <style>
        body { font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif; background-color: #f0f2f5; margin: 0; }
        .dashboard { max-width: 1200px; margin: auto; padding: 20px; }
        .port-section { margin-bottom: 40px; }
        .port-title { font-size: 2em; color: #1c2a38; margin-bottom: 20px; border-bottom: 3px solid #e0e0e0; padding-bottom: 10px; }
        .port-layout { display: flex; flex-wrap: wrap; gap: 40px; }
        .category-column { flex: 1; min-width: 300px; }
        .category-title { font-size: 1.5em; color: #444; margin-top: 0; }
        .card-container { display: grid; grid-template-columns: 1fr; gap: 20px; }
        .card { background-color: white; border-radius: 8px; box-shadow: 0 4px 6px rgba(0,0,0,0.1); padding: 20px; border-left: 5px solid #ccc; display: flex; flex-direction: column; }
        .card.status-closed { background-color: #f8f9fa; border-left-color: #6c757d; }
        .card.status-closed .wait-time { color: #6c757d; }
        .card h3 { margin-top: 0; font-size: 1.25em; color: #333; }
        .card .wait-time { font-size: 3em; font-weight: 700; margin: 10px 0; }
        .card .lanes-open { font-size: 1em; color: #555; font-weight: 600; flex-grow: 1; }
        .card .last-updated { font-size: 0.9em; color: #777; margin-top: 15px; }
        .status-green { border-left-color: #28a745; }
        .status-yellow { border-left-color: #ffc107; }
        .status-red { border-left-color: #dc3545; }
    </style>
</head>
<body>
    <div id="dashboard" class="dashboard">
        <h1>Live Border Wait Times</h1>
        <p id="loading">Loading live data from CBP...</p>
    </div>

    <script>
        const rssUrl = 'https://bwt.cbp.gov/api/bwtRss/CSV/-1/57,55/57,55,106';
        const fetchUrl = rssUrl;

        const dashboard = document.getElementById('dashboard');
        const loadingMessage = document.getElementById('loading');

        function normalizePortName(name) { return name.split(' - ')[0]; }
        function getStatusColor(status, waitTime) {
            if (status !== 'Open') return 'status-closed';
            const minutes = parseInt(waitTime);
            if (isNaN(minutes)) return '';
            if (minutes <= 20) return 'status-green';
            if (minutes <= 60) return 'status-yellow';
            return 'status-red';
        }

        /**
         * A new, robust parser that reads the description line-by-line to correctly
         * identify and extract all vehicle and pedestrian lane data.
         */
        function parseLanesFromDescription(description, originalPortName) {
            const allLanes = [];
            const lines = description.split('\n');
            let currentCategory = '';

            // Handle the PedWest special case directly
            if (originalPortName.includes('PedWest')) {
                const laneName = "Pedestrian West";
                let status = 'Pending', waitTime = 'N/A', lanesOpen = 'N/A', updateTime = '';
                if (description.includes("Lanes Closed")) {
                    status = 'Closed'; lanesOpen = '0';
                } else {
                    const waitMatch = description.match(/(\d+)\s+min delay/);
                    const lanesMatch = description.match(/(\d+)\s+lane\(s\)\s+open/);
                    const timeMatch = description.match(/At\s+([\d:]+\s*[ap]m\s*\w+)/);
                    if (waitMatch) {
                        status = 'Open';
                        waitTime = waitMatch[1];
                        lanesOpen = lanesMatch ? lanesMatch[1] : '?';
                        updateTime = timeMatch ? timeMatch[0] : '';
                    }
                }
                allLanes.push({ name: laneName, status, waitTime, lanesOpen, updateTime, type: 'pedestrian' });
                return allLanes;
            }

            // Standard line-by-line parsing for all other ports
            for (const line of lines) {
                // Check if the line is a category header
                if (line.includes('Passenger Vehicles')) {
                    currentCategory = 'vehicle';
                    continue; // Move to the next line
                } else if (line.includes('Pedestrian')) {
                    currentCategory = 'pedestrian';
                    continue; // Move to the next line
                }

                // If we haven't identified a category yet, skip
                if (!currentCategory) continue;

                const laneTypes = ['General Lanes', 'Ready Lanes', 'SENTRI Lanes'];
                for (const laneType of laneTypes) {
                    if (line.trim().startsWith(laneType)) {
                        let status = 'Pending', waitTime = 'N/A', lanesOpen = 'N/A', updateTime = '';
                        
                        if (line.includes("Lanes Closed")) {
                            status = 'Closed'; lanesOpen = '0';
                        } else {
                            const waitMatch = line.match(/(\d+)\s+min delay/);
                            const lanesMatch = line.match(/(\d+)\s+lane\(s\)\s+open/);
                            const timeMatch = line.match(/At\s+([\d:]+\s*[ap]m\s*\w+)/);

                            if (waitMatch) {
                                status = 'Open';
                                waitTime = waitMatch[1];
                                lanesOpen = lanesMatch ? lanesMatch[1] : '?';
                                updateTime = timeMatch ? timeMatch[0] : '';
                            }
                        }
                        
                        const laneName = laneType.replace(' Lanes', '');
                        allLanes.push({ name: laneName, status, waitTime, lanesOpen, updateTime, type: currentCategory });
                        break; // Found a lane type on this line, move to the next line
                    }
                }
            }
            return allLanes;
        }

        fetch(fetchUrl)
            .then(response => response.ok ? response.text() : Promise.reject('Network response was not ok.'))
            .then(xmlText => {
                const parser = new DOMParser();
                const xmlDoc = parser.parseFromString(xmlText, "text/xml");
                const items = xmlDoc.getElementsByTagName('item');
                const portData = {};

                for (const item of items) {
                    const originalPortName = item.querySelector('title').textContent;
                    const normalizedPortName = normalizePortName(originalPortName);
                    const description = item.querySelector('description').textContent;
                    const parsedLanes = parseLanesFromDescription(description, originalPortName);

                    if (parsedLanes.length > 0) {
                        if (!portData[normalizedPortName]) {
                            portData[normalizedPortName] = [];
                        }
                        portData[normalizedPortName].push(...parsedLanes);
                    }
                }
                
                if (loadingMessage) loadingMessage.style.display = 'none';

                for (const portName in portData) {
                    const lanes = portData[portName];
                    const vehicleLanes = lanes.filter(lane => lane.type === 'vehicle');
                    const pedestrianLanes = lanes.filter(lane => lane.type === 'pedestrian');

                    let portHtml = `<section class="port-section">
                                        <h2 class="port-title">${portName}</h2>
                                        <div class="port-layout">`;
                    
                    if (vehicleLanes.length > 0) {
                        portHtml += `<div class="category-column"><h3 class="category-title">Vehicles</h3><div class="card-container">`;
                        vehicleLanes.forEach(lane => {
                            const waitTimeDisplay = lane.status === 'Open' ? `${lane.waitTime} min` : lane.status;
                            const colorClass = getStatusColor(lane.status, lane.waitTime);
                            const lanesOpenDisplay = lane.status === 'Closed' ? 'All lanes closed' : `${lane.lanesOpen} lane(s) open`;
                            const updatedDisplay = lane.updateTime ? `As of ${lane.updateTime}` : '';
                            portHtml += `<div class="card ${colorClass}"><h3>${lane.name}</h3><div class="wait-time">${waitTimeDisplay}</div><div class="lanes-open">${lanesOpenDisplay}</div><div class="last-updated">${updatedDisplay}</div></div>`;
                        });
                        portHtml += `</div></div>`;
                    }

                    if (pedestrianLanes.length > 0) {
                         portHtml += `<div class="category-column"><h3 class="category-title">Pedestrians</h3><div class="card-container">`;
                        pedestrianLanes.forEach(lane => {
                            const waitTimeDisplay = lane.status === 'Open' ? `${lane.waitTime} min` : lane.status;
                            const colorClass = getStatusColor(lane.status, lane.waitTime);
                            const lanesOpenDisplay = lane.status === 'Closed' ? 'All lanes closed' : `${lane.lanesOpen} lane(s) open`;
                            const updatedDisplay = lane.updateTime ? `As of ${lane.updateTime}` : '';
                            portHtml += `<div class="card ${colorClass}"><h3>${lane.name}</h3><div class="wait-time">${waitTimeDisplay}</div><div class="lanes-open">${lanesOpenDisplay}</div><div class="last-updated">${updatedDisplay}</div></div>`;
                        });
                        portHtml += `</div></div>`;
                    }

                    portHtml += `</div></section>`;
                    dashboard.innerHTML += portHtml;
                }
            })
            .catch(error => {
                if(loadingMessage) loadingMessage.textContent = 'Failed to load data. The API may be down.';
                console.error('Fetch Error:', error);
            });
    </script>
</body>
</html>