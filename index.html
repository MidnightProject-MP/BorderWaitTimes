<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Live Border Wait Times</title>
    <style>
        body { font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif; background-color: #f0f2f5; margin: 0; }
        .dashboard { max-width: 1200px; margin: auto; padding: 20px; }
        .port-section { margin-bottom: 40px; }
        .port-title { font-size: 2em; color: #1c2a38; margin-bottom: 20px; border-bottom: 3px solid #e0e0e0; padding-bottom: 10px; }
        .port-layout { display: flex; flex-wrap: wrap; gap: 40px; }
        .category-column { flex: 1; min-width: 300px; }
        .category-title { font-size: 1.5em; color: #444; margin-top: 0; }
        .filter-controls { background-color: #fff; padding: 15px 20px; border-radius: 8px; margin-bottom: 20px; box-shadow: 0 2px 4px rgba(0,0,0,0.05); display: flex; gap: 40px; align-items: center; flex-wrap: wrap; }
        .filter-controls > div { display: flex; align-items: center; gap: 15px; flex-wrap: wrap; }
        .filter-controls h3 { margin: 0; font-size: 1em; color: #333; }
        .filter-controls label { cursor: pointer; user-select: none; }
        .port-title.collapsible { cursor: pointer; position: relative; user-select: none; }
        .port-title.collapsible::after { content: '+'; font-weight: bold; position: absolute; right: 10px; transition: transform 0.2s ease-in-out; font-size: 1.5em; top: 50%; transform: translateY(-55%); }
        .port-title.collapsible.active::after { content: 'âˆ’'; }
        .port-layout { max-height: 0; overflow: hidden; transition: max-height 0.4s ease-out; }
        .card-container { display: flex; flex-wrap: wrap; gap: 20px; }
        .card { background-color: white; border-radius: 8px; box-shadow: 0 4px 6px rgba(0,0,0,0.1); padding: 20px; border-left: 5px solid #ccc; display: flex; flex-direction: column; flex: 1; min-width: 160px; }
        .card.status-no-data { background-color: #f8f9fa; border-left-color: #e0e0e0; }
        .card.status-closed .wait-time, .card.status-no-data .wait-time { color: #6c757d; }
        .card h3 { margin-top: 0; font-size: 1.25em; color: #333; }
        .card .wait-time { font-size: 3em; font-weight: 700; margin: 10px 0; }
        .card .lanes-open { font-size: 1em; color: #555; font-weight: 600; flex-grow: 1; }
        .card .last-updated { font-size: 0.9em; color: #777; margin-top: 15px; }
        .status-green { border-left-color: #28a745; }
        .status-yellow { border-left-color: #ffc107; }
        .status-red { border-left-color: #dc3545; }
    </style>
</head>
<body>
    <div id="dashboard" class="dashboard">
        <h1>Live Border Wait Times</h1>
        <div class="filter-controls">
            <div>
                <h3>Mode:</h3>
                <label><input type="checkbox" name="mode-filter" value="Vehicles" checked> Vehicles</label>
                <label><input type="checkbox" name="mode-filter" value="Pedestrians" checked> Pedestrians</label>
                <label><input type="checkbox" name="mode-filter" value="PedWest" checked> PedWest</label>
            </div>
            <div>
                <h3>Lane Type:</h3>
                <label><input type="checkbox" name="lane-filter" value="General" checked> General</label>
                <label><input type="checkbox" name="lane-filter" value="Ready" checked> Ready</label>
                <label><input type="checkbox" name="lane-filter" value="Sentri" checked> Sentri</label>
            </div>
        </div>
        <p id="loading">Loading live data from CBP...</p>
    </div>

    <script>
        const rssUrl = 'https://bwt.cbp.gov/api/bwtRss/CSV/-1/57,55/57,55,106';
        const fetchUrl = rssUrl;

        const dashboard = document.getElementById('dashboard');
        const loadingMessage = document.getElementById('loading');

        /**
         * Creates a blank "template" object for a port with all possible lanes.
         */
        function createPortTemplate(portName) {
            const laneTemplate = () => ({ status: 'N/A', waitTime: 'N/A', lanesOpen: 'N/A', updateTime: '' });
            return {
                portName: portName,
                vehicles: { 'General': laneTemplate(), 'Ready': laneTemplate(), 'Sentri': laneTemplate() },
                pedestrians: { 'General': laneTemplate(), 'Ready': laneTemplate(), 'Sentri': laneTemplate() }
            };
        }

        /**
         * A targeted function to extract data for one specific lane from a text block.
         */
        function extractLaneData(textChunk, laneFullName) {
            console.groupCollapsed(`Extracting data for: "${laneFullName}"`);
            const laneData = { status: 'N/A', waitTime: 'N/A', lanesOpen: 'N/A', updateTime: '' };

            if (!textChunk || !textChunk.includes(laneFullName + ":")) {
                console.log(`Lane not found in provided text chunk.`);
                console.groupEnd();
                return laneData;
            }

            const laneChunk = textChunk.split(laneFullName + ":")[1] || '';
            console.log(`Raw lane chunk:`, laneChunk);

            if (laneChunk.includes("Lanes Closed")) {
                laneData.status = 'Closed';
                laneData.lanesOpen = '0';
            } else {
                const waitMatch = laneChunk.match(/(\d+)\s+min delay/);
                const lanesMatch = laneChunk.match(/(\d+)\s+lane\(s\)\s+open/);
                const timeMatch = laneChunk.match(/At\s+([\d:]+\s*[ap]m\s*\w+)/);

                if (waitMatch) {
                    laneData.status = 'Open';
                    laneData.waitTime = waitMatch[1];
                    laneData.lanesOpen = lanesMatch ? lanesMatch[1] : '?';
                    laneData.updateTime = timeMatch ? timeMatch[0] : '';
                }
            }
            console.log(`Result:`, laneData);
            console.groupEnd();
            return laneData;
        }

        fetch(fetchUrl)
            .then(response => response.ok ? response.text() : Promise.reject('Network response was not ok.'))
            .then(xmlText => {
                console.log("Data fetched successfully. Starting to parse XML.");
                const parser = new DOMParser();
                const xmlDoc = parser.parseFromString(xmlText, "text/xml");
                const items = xmlDoc.getElementsByTagName('item');
                console.log(`Found ${items.length} items in the RSS feed.`);
                const portData = {};

                for (const item of items) {
                    const originalPortName = item.querySelector('title').textContent;
                    console.groupCollapsed(`Processing Item: ${originalPortName}`);
                    const portName = originalPortName.split(' - ')[0];
                    const description = item.querySelector('description').textContent;

                    if (!portData[portName]) {
                        console.log(`Creating new template for port.`);
                        portData[portName] = createPortTemplate(portName);
                    }

                    const vehicleChunk = description.split('Passenger Vehicles')[1] ? description.split('Passenger Vehicles')[1].split('Pedestrian')[0] : '';
                    const pedestrianChunk = description.split('Pedestrian')[1] ? description.split('Pedestrian')[1] : '';
                    console.log("Vehicle Chunk:", vehicleChunk);
                    console.log("Pedestrian Chunk:", pedestrianChunk);

                    // Fill in the template with data
                    if (originalPortName.includes('PedWest')) {
                        console.log("Handling special case: PedWest");
                        // The description for PedWest contains its own lane data under 'General' and 'Ready'.
                        // We parse them directly from the full description text.
                        portData[portName].pedwest = {
                            'General': extractLaneData(description, 'General Lanes'),
                            'Ready': extractLaneData(description, 'Ready Lanes')
                        };
                    } else {
                        // Standard vehicle lanes
                        portData[portName].vehicles['General'] = extractLaneData(vehicleChunk, 'General Lanes');
                        portData[portName].vehicles['Ready'] = extractLaneData(vehicleChunk, 'Ready Lanes');
                        portData[portName].vehicles['Sentri'] = extractLaneData(vehicleChunk, 'Sentri Lanes');

                        // Standard pedestrian lanes
                        portData[portName].pedestrians['General'] = extractLaneData(pedestrianChunk, 'General Lanes');
                        portData[portName].pedestrians['Ready'] = extractLaneData(pedestrianChunk, 'Ready Lanes');
                    }
                    console.log(`Finished processing. Current data for ${portName}:`, JSON.parse(JSON.stringify(portData[portName])));
                    console.groupEnd();
                }

                console.log("%c--- All items parsed. Final data structure: ---", "font-weight: bold; font-size: 1.2em;", portData);
                if (loadingMessage) loadingMessage.style.display = 'none';

                console.log("%c--- Starting DOM Generation ---", "font-weight: bold; font-size: 1.2em;");
                for (const portName in portData) {
                    console.log(`Generating HTML for port: ${portName}`);
                    const port = portData[portName];
                    let vehicleHtml = '';
                    let pedestrianHtml = '';
                    let pedwestHtml = '';

                    // Build Vehicle Column
                    const hasVisibleVehicleLanes = Object.values(port.vehicles).some(lane => lane.status !== 'N/A');
                    if (hasVisibleVehicleLanes) {
                        vehicleHtml += `<div class="category-column" data-mode-type="Vehicles"><h3 class="category-title">Vehicles</h3><div class="card-container">`;
                        for (const laneName in port.vehicles) {
                            const lane = port.vehicles[laneName];
                            if (lane.status === 'N/A') continue; // Hide lanes with no data
                            const waitTimeDisplay = lane.status === 'Open' ? `${lane.waitTime} min` : lane.status;
                            const colorClass = getStatusColor(lane.status, lane.waitTime);
                            const lanesOpenDisplay = lane.status === 'Closed' ? 'All lanes closed' : (lane.lanesOpen !== 'N/A' ? `${lane.lanesOpen} lane(s) open` : '');
                            const updatedDisplay = lane.updateTime ? `${lane.updateTime}` : '';
                            vehicleHtml += `<div class="card ${colorClass}" data-lane-type="${laneName}"><h3>${laneName}</h3><div class="wait-time">${waitTimeDisplay}</div><div class="lanes-open">${lanesOpenDisplay}</div><div class="last-updated">${updatedDisplay}</div></div>`;
                        }
                        vehicleHtml += `</div></div>`;
                    }

                    // Build Pedestrian Column
                    const hasVisiblePedestrianLanes = Object.values(port.pedestrians).some(lane => lane.status !== 'N/A');
                    if (hasVisiblePedestrianLanes) {
                        pedestrianHtml += `<div class="category-column" data-mode-type="Pedestrians"><h3 class="category-title">Pedestrians</h3><div class="card-container">`;
                        for (const laneName in port.pedestrians) {
                            const lane = port.pedestrians[laneName];
                            if (lane.status === 'N/A' || laneName === 'Sentri') continue; // Hide lanes with no data and Ped Sentri
                            const waitTimeDisplay = lane.status === 'Open' ? `${lane.waitTime} min` : lane.status;
                            const colorClass = getStatusColor(lane.status, lane.waitTime);
                            const lanesOpenDisplay = lane.status === 'Closed' ? 'All lanes closed' : (lane.lanesOpen !== 'N/A' ? `${lane.lanesOpen} lane(s) open` : '');
                            const updatedDisplay = lane.updateTime ? `${lane.updateTime}` : '';
                            pedestrianHtml += `<div class="card ${colorClass}" data-lane-type="${laneName}"><h3>${laneName}</h3><div class="wait-time">${waitTimeDisplay}</div><div class="lanes-open">${lanesOpenDisplay}</div><div class="last-updated">${updatedDisplay}</div></div>`;
                        }
                        pedestrianHtml += `</div></div>`;
                    }

                    // Build PedWest Column
                    const hasVisiblePedWestLanes = port.pedwest && Object.values(port.pedwest).some(lane => lane.status !== 'N/A');
                    if (hasVisiblePedWestLanes) {
                        pedwestHtml += `<div class="category-column" data-mode-type="PedWest"><h3 class="category-title">PedWest</h3><div class="card-container">`;
                        for (const laneName in port.pedwest) {
                            const lane = port.pedwest[laneName];
                            if (lane.status === 'N/A') continue;
                            const waitTimeDisplay = lane.status === 'Open' ? `${lane.waitTime} min` : lane.status;
                            const colorClass = getStatusColor(lane.status, lane.waitTime);
                            const lanesOpenDisplay = lane.status === 'Closed' ? 'All lanes closed' : (lane.lanesOpen !== 'N/A' ? `${lane.lanesOpen} lane(s) open` : '');
                            const updatedDisplay = lane.updateTime ? `${lane.updateTime}` : '';
                            pedwestHtml += `<div class="card ${colorClass}" data-lane-type="${laneName}"><h3>${laneName}</h3><div class="wait-time">${waitTimeDisplay}</div><div class="lanes-open">${lanesOpenDisplay}</div><div class="last-updated">${updatedDisplay}</div></div>`;
                        }
                        pedwestHtml += `</div></div>`;
                    }

                    // Only add the port section if it has at least one visible category
                    if (vehicleHtml || pedestrianHtml || pedwestHtml) {
                        let portHtml = `<section class="port-section"><h2 class="port-title collapsible">${portName}</h2><div class="port-layout">`;
                        portHtml += vehicleHtml;
                        portHtml += pedestrianHtml;
                        portHtml += pedwestHtml;
                        portHtml += `</div></section>`;
                        dashboard.innerHTML += portHtml;
                    }
                }

                setupInteractiveDashboard();
            })
            .catch(error => {
                if(loadingMessage) loadingMessage.textContent = 'Failed to load data. The API may be down.';
                console.error('Fetch Error:', error);
            });

        function getStatusColor(status, waitTime) {
            if (status !== 'Open') return 'status-closed';
            const minutes = parseInt(waitTime);
            if (isNaN(minutes)) return '';
            if (minutes <= 20) return 'status-green';
            if (minutes <= 60) return 'status-yellow';
            return 'status-red';
        }

        /**
         * Applies filters to hide/show cards and sections based on checkbox selections.
         */
        function applyFilters() {
            const checkedLaneFilters = Array.from(document.querySelectorAll('input[name="lane-filter"]:checked')).map(cb => cb.value);
            const checkedModeFilters = Array.from(document.querySelectorAll('input[name="mode-filter"]:checked')).map(cb => cb.value);

            document.querySelectorAll('.port-section').forEach(port => {
                let portHasVisibleCards = false;
                port.querySelectorAll('.category-column').forEach(category => {
                    const modeType = category.dataset.modeType;
                    if (!checkedModeFilters.includes(modeType)) {
                        category.style.display = 'none';
                        return;
                    }

                    let categoryHasVisibleCards = false;
                    category.querySelectorAll('.card').forEach(card => {
                        const laneType = card.dataset.laneType;
                        if (checkedLaneFilters.includes(laneType)) {
                            card.style.display = 'flex';
                            categoryHasVisibleCards = true;
                            portHasVisibleCards = true;
                        } else {
                            card.style.display = 'none';
                        }
                    });
                    category.style.display = categoryHasVisibleCards ? 'block' : 'none';
                });

                port.style.display = portHasVisibleCards ? 'block' : 'none';

                // Recalculate height for the port's layout if it's visible and active (expanded)
                if (portHasVisibleCards) {
                    const header = port.querySelector('.port-title.collapsible');
                    const content = port.querySelector('.port-layout');
                    if (header.classList.contains('active')) {
                        content.style.maxHeight = content.scrollHeight + 'px';
                    }
                }
            });
        }

        /**
         * Sets up all event listeners for interactive elements after they are rendered.
         */
        function setupInteractiveDashboard() {
            // Setup collapsible port sections
            document.querySelectorAll('.port-title.collapsible').forEach(header => {
                header.addEventListener('click', () => {
                    header.classList.toggle('active');
                    const content = header.nextElementSibling;
                    if (header.classList.contains('active')) {
                        content.style.maxHeight = content.scrollHeight + 'px';
                    } else {
                        content.style.maxHeight = '0px';
                    }
                });

                // Start expanded by default
                header.classList.add('active');
                const content = header.nextElementSibling;
                // Use a small timeout to ensure browser has rendered and calculated scrollHeight
                setTimeout(() => {
                    if (header.classList.contains('active')) {
                        content.style.maxHeight = content.scrollHeight + 'px';
                    }
                }, 10);
            });

            // Setup filter checkboxes
            document.querySelectorAll('input[name="lane-filter"], input[name="mode-filter"]').forEach(checkbox => {
                checkbox.addEventListener('change', applyFilters);
            });
        }
    </script>
</body>
</html>